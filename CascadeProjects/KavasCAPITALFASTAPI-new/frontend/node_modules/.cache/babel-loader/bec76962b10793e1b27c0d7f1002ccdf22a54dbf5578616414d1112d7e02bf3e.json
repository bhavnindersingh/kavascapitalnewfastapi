{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nimport { store } from '../store';\nconst initialState = {\n  connected: false,\n  subscriptions: [],\n  clientId: null,\n  error: null\n};\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.baseUrl = void 0;\n    this.messageHandlers = new Set();\n    this.subscriptions = new Set();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = 3000;\n    this.clientId = null;\n    this.reconnectTimer = null;\n    this.baseUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/api/v1/kite/ws';\n  }\n  connect(clientId, initialSubscriptions = []) {\n    // Clear any existing connection\n    this.disconnect();\n    this.clientId = clientId;\n    const accessToken = localStorage.getItem('kite_access_token');\n    if (!accessToken) {\n      console.error('No access token found');\n      store.dispatch(websocketSlice.actions.setError('No access token found'));\n      return;\n    }\n    const url = `${this.baseUrl}/${clientId}?token=${accessToken}`;\n    try {\n      this.ws = new WebSocket(url);\n      this.ws.onopen = () => {\n        console.log('WebSocket connected');\n        this.reconnectAttempts = 0;\n        store.dispatch(websocketSlice.actions.setError(null));\n\n        // Resubscribe to previous subscriptions\n        if (initialSubscriptions.length > 0) {\n          this.subscribe(initialSubscriptions);\n        }\n      };\n      this.ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this.messageHandlers.forEach(handler => handler(data));\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n          store.dispatch(websocketSlice.actions.setError('Error parsing WebSocket message'));\n        }\n      };\n      this.ws.onclose = event => {\n        console.log('WebSocket disconnected', event.code, event.reason);\n        this.handleDisconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n        store.dispatch(websocketSlice.actions.setError('WebSocket connection error'));\n        this.handleDisconnect();\n      };\n    } catch (error) {\n      console.error('Error connecting to WebSocket:', error);\n      store.dispatch(websocketSlice.actions.setError('Failed to connect to WebSocket'));\n      this.handleDisconnect();\n    }\n  }\n  handleDisconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`WebSocket disconnected. Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n\n      // Clear any existing reconnect timer\n      if (this.reconnectTimer) {\n        clearTimeout(this.reconnectTimer);\n      }\n      this.reconnectTimer = setTimeout(() => {\n        if (this.clientId) {\n          this.connect(this.clientId, Array.from(this.subscriptions));\n        }\n      }, this.reconnectTimeout * this.reconnectAttempts); // Exponential backoff\n    } else {\n      console.error('Max reconnection attempts reached');\n      store.dispatch(websocketSlice.actions.setError('Failed to reconnect after multiple attempts'));\n    }\n  }\n  disconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    if (this.ws) {\n      // Only close if not already closing or closed\n      if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {\n        this.ws.close();\n      }\n      this.ws = null;\n    }\n    this.messageHandlers.clear();\n    this.subscriptions.clear();\n    this.clientId = null;\n    this.reconnectAttempts = 0;\n  }\n  subscribe(instrumentTokens) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      return;\n    }\n    try {\n      const message = {\n        type: 'subscribe',\n        tokens: instrumentTokens\n      };\n      this.ws.send(JSON.stringify(message));\n      instrumentTokens.forEach(token => this.subscriptions.add(token));\n    } catch (error) {\n      console.error('Error subscribing to tokens:', error);\n      store.dispatch(websocketSlice.actions.setError('Failed to subscribe to market data'));\n    }\n  }\n  unsubscribe(instrumentTokens) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      return;\n    }\n    try {\n      const message = {\n        type: 'unsubscribe',\n        tokens: instrumentTokens\n      };\n      this.ws.send(JSON.stringify(message));\n      instrumentTokens.forEach(token => this.subscriptions.delete(token));\n    } catch (error) {\n      console.error('Error unsubscribing from tokens:', error);\n    }\n  }\n  addMessageHandler(handler) {\n    this.messageHandlers.add(handler);\n  }\n  removeMessageHandler(handler) {\n    this.messageHandlers.delete(handler);\n  }\n}\nexport const websocketService = new WebSocketService();\nexport const websocketSlice = createSlice({\n  name: 'websocket',\n  initialState,\n  reducers: {\n    setConnected: (state, action) => {\n      state.connected = action.payload;\n    },\n    setClientId: (state, action) => {\n      state.clientId = action.payload;\n    },\n    addSubscription: (state, action) => {\n      if (!state.subscriptions.includes(action.payload)) {\n        state.subscriptions.push(action.payload);\n      }\n    },\n    removeSubscription: (state, action) => {\n      state.subscriptions = state.subscriptions.filter(id => id !== action.payload);\n    },\n    setError: (state, action) => {\n      state.error = action.payload;\n    }\n  }\n});\nexport const {\n  setConnected,\n  setClientId,\n  addSubscription,\n  removeSubscription\n} = websocketSlice.actions;\nexport default websocketSlice.reducer;","map":{"version":3,"names":["createSlice","store","initialState","connected","subscriptions","clientId","error","WebSocketService","constructor","ws","baseUrl","messageHandlers","Set","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","reconnectTimer","process","env","REACT_APP_WS_URL","connect","initialSubscriptions","disconnect","accessToken","localStorage","getItem","console","dispatch","websocketSlice","actions","setError","url","WebSocket","onopen","log","length","subscribe","onmessage","event","data","JSON","parse","forEach","handler","onclose","code","reason","handleDisconnect","onerror","clearTimeout","setTimeout","Array","from","readyState","OPEN","CONNECTING","close","clear","instrumentTokens","message","type","tokens","send","stringify","token","add","unsubscribe","delete","addMessageHandler","removeMessageHandler","websocketService","name","reducers","setConnected","state","action","payload","setClientId","addSubscription","includes","push","removeSubscription","filter","id","reducer"],"sources":["C:/Users/inder/CascadeProjects/KavasCAPITALFASTAPI-new/frontend/src/services/websocket.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MarketData } from '../types/market';\nimport { store } from '../store';\n\ninterface WebSocketState {\n  connected: boolean;\n  subscriptions: number[];\n  clientId: string | null;\n  error: string | null;\n}\n\nconst initialState: WebSocketState = {\n  connected: false,\n  subscriptions: [],\n  clientId: null,\n  error: null,\n};\n\ntype MessageHandler = (data: MarketData) => void;\n\nclass WebSocketService {\n  private ws: WebSocket | null = null;\n  private readonly baseUrl: string;\n  private messageHandlers: Set<MessageHandler> = new Set();\n  private subscriptions: Set<number> = new Set();\n  private reconnectAttempts: number = 0;\n  private readonly maxReconnectAttempts: number = 5;\n  private readonly reconnectTimeout: number = 3000;\n  private clientId: string | null = null;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n\n  constructor() {\n    this.baseUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/api/v1/kite/ws';\n  }\n\n  connect(clientId: string, initialSubscriptions: number[] = []) {\n    // Clear any existing connection\n    this.disconnect();\n    \n    this.clientId = clientId;\n    const accessToken = localStorage.getItem('kite_access_token');\n    if (!accessToken) {\n      console.error('No access token found');\n      store.dispatch(websocketSlice.actions.setError('No access token found'));\n      return;\n    }\n\n    const url = `${this.baseUrl}/${clientId}?token=${accessToken}`;\n    \n    try {\n      this.ws = new WebSocket(url);\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket connected');\n        this.reconnectAttempts = 0;\n        store.dispatch(websocketSlice.actions.setError(null));\n        \n        // Resubscribe to previous subscriptions\n        if (initialSubscriptions.length > 0) {\n          this.subscribe(initialSubscriptions);\n        }\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          this.messageHandlers.forEach(handler => handler(data));\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n          store.dispatch(websocketSlice.actions.setError('Error parsing WebSocket message'));\n        }\n      };\n\n      this.ws.onclose = (event) => {\n        console.log('WebSocket disconnected', event.code, event.reason);\n        this.handleDisconnect();\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        store.dispatch(websocketSlice.actions.setError('WebSocket connection error'));\n        this.handleDisconnect();\n      };\n    } catch (error) {\n      console.error('Error connecting to WebSocket:', error);\n      store.dispatch(websocketSlice.actions.setError('Failed to connect to WebSocket'));\n      this.handleDisconnect();\n    }\n  }\n\n  private handleDisconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`WebSocket disconnected. Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      \n      // Clear any existing reconnect timer\n      if (this.reconnectTimer) {\n        clearTimeout(this.reconnectTimer);\n      }\n\n      this.reconnectTimer = setTimeout(() => {\n        if (this.clientId) {\n          this.connect(this.clientId, Array.from(this.subscriptions));\n        }\n      }, this.reconnectTimeout * this.reconnectAttempts); // Exponential backoff\n    } else {\n      console.error('Max reconnection attempts reached');\n      store.dispatch(websocketSlice.actions.setError('Failed to reconnect after multiple attempts'));\n    }\n  }\n\n  disconnect() {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    if (this.ws) {\n      // Only close if not already closing or closed\n      if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {\n        this.ws.close();\n      }\n      this.ws = null;\n    }\n\n    this.messageHandlers.clear();\n    this.subscriptions.clear();\n    this.clientId = null;\n    this.reconnectAttempts = 0;\n  }\n\n  subscribe(instrumentTokens: number[]) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      return;\n    }\n\n    try {\n      const message = {\n        type: 'subscribe',\n        tokens: instrumentTokens\n      };\n      this.ws.send(JSON.stringify(message));\n      instrumentTokens.forEach(token => this.subscriptions.add(token));\n    } catch (error) {\n      console.error('Error subscribing to tokens:', error);\n      store.dispatch(websocketSlice.actions.setError('Failed to subscribe to market data'));\n    }\n  }\n\n  unsubscribe(instrumentTokens: number[]) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      return;\n    }\n\n    try {\n      const message = {\n        type: 'unsubscribe',\n        tokens: instrumentTokens\n      };\n      this.ws.send(JSON.stringify(message));\n      instrumentTokens.forEach(token => this.subscriptions.delete(token));\n    } catch (error) {\n      console.error('Error unsubscribing from tokens:', error);\n    }\n  }\n\n  addMessageHandler(handler: MessageHandler) {\n    this.messageHandlers.add(handler);\n  }\n\n  removeMessageHandler(handler: MessageHandler) {\n    this.messageHandlers.delete(handler);\n  }\n}\n\nexport const websocketService = new WebSocketService();\n\nexport const websocketSlice = createSlice({\n  name: 'websocket',\n  initialState,\n  reducers: {\n    setConnected: (state, action: PayloadAction<boolean>) => {\n      state.connected = action.payload;\n    },\n    setClientId: (state, action: PayloadAction<string>) => {\n      state.clientId = action.payload;\n    },\n    addSubscription: (state, action: PayloadAction<number>) => {\n      if (!state.subscriptions.includes(action.payload)) {\n        state.subscriptions.push(action.payload);\n      }\n    },\n    removeSubscription: (state, action: PayloadAction<number>) => {\n      state.subscriptions = state.subscriptions.filter(id => id !== action.payload);\n    },\n    setError: (state, action: PayloadAction<string | null>) => {\n      state.error = action.payload;\n    }\n  },\n});\n\nexport const {\n  setConnected,\n  setClientId,\n  addSubscription,\n  removeSubscription,\n} = websocketSlice.actions;\n\nexport default websocketSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}