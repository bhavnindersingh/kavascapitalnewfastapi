{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback, useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { optionsApi } from '../services/api';\nimport { webSocketService } from '../services/websocket';\nimport { setError, setLoading, setOptionChainData, updateOptionData } from '../store/slices/optionChainSlice';\nexport const useMarketData = (symbol, selectedExpiry) => {\n  _s();\n  const dispatch = useDispatch();\n  const optionChainData = useSelector(state => state.optionChain.data);\n  const handleMarketData = useCallback(message => {\n    if (message.type === 'MARKET_DATA' && message.data) {\n      const marketData = message.data;\n      // Update the specific option's data in the chain\n      if (optionChainData) {\n        const updatedStrikes = optionChainData.strikes.map(strike => {\n          if (strike.call.instrument_token === marketData.instrument_token) {\n            return {\n              ...strike,\n              call: {\n                ...strike.call,\n                ltp: marketData.last_price,\n                oi: marketData.oi,\n                change: marketData.change\n              }\n            };\n          }\n          if (strike.put.instrument_token === marketData.instrument_token) {\n            return {\n              ...strike,\n              put: {\n                ...strike.put,\n                ltp: marketData.last_price,\n                oi: marketData.oi,\n                change: marketData.change\n              }\n            };\n          }\n          return strike;\n        });\n        dispatch(updateOptionData({\n          strikes: updatedStrikes\n        }));\n      }\n    }\n  }, [optionChainData, dispatch]);\n\n  // Fetch initial option chain data\n  useEffect(() => {\n    const fetchOptionChain = async () => {\n      if (!symbol || !selectedExpiry) return;\n      try {\n        dispatch(setLoading(true));\n        const response = await optionsApi.getOptionChain(symbol, selectedExpiry);\n        dispatch(setOptionChainData(response.data));\n      } catch (error) {\n        dispatch(setError(error instanceof Error ? error.message : 'Failed to fetch option chain'));\n      } finally {\n        dispatch(setLoading(false));\n      }\n    };\n    fetchOptionChain();\n  }, [symbol, selectedExpiry, dispatch]);\n\n  // Subscribe to market data updates\n  useEffect(() => {\n    if (optionChainData !== null && optionChainData !== void 0 && optionChainData.strikes) {\n      // Extract instrument tokens from both calls and puts\n      const instrumentTokens = optionChainData.strikes.flatMap(strike => [strike.call.instrument_token, strike.put.instrument_token]);\n      webSocketService.subscribe(instrumentTokens);\n      webSocketService.addMessageHandler(handleMarketData);\n      return () => {\n        webSocketService.unsubscribe(instrumentTokens);\n        webSocketService.removeMessageHandler(handleMarketData);\n      };\n    }\n  }, [optionChainData, handleMarketData]);\n  return {\n    optionChainData\n  };\n};\n_s(useMarketData, \"yWpLDXMD4OeJC1ZvpIzoHdjVpMs=\", false, function () {\n  return [useDispatch, useSelector];\n});","map":{"version":3,"names":["useCallback","useEffect","useDispatch","useSelector","optionsApi","webSocketService","setError","setLoading","setOptionChainData","updateOptionData","useMarketData","symbol","selectedExpiry","_s","dispatch","optionChainData","state","optionChain","data","handleMarketData","message","type","marketData","updatedStrikes","strikes","map","strike","call","instrument_token","ltp","last_price","oi","change","put","fetchOptionChain","response","getOptionChain","error","Error","instrumentTokens","flatMap","subscribe","addMessageHandler","unsubscribe","removeMessageHandler"],"sources":["C:/Users/inder/CascadeProjects/KavasCAPITALFASTAPI-new/frontend/src/hooks/useMarketData.ts"],"sourcesContent":["import { useCallback, useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { optionsApi } from '../services/api';\nimport { webSocketService } from '../services/websocket';\nimport type { MarketData, WSMessage, OptionChainData } from '../types/options';\nimport { RootState } from '../store';\nimport { setError, setLoading, setOptionChainData, updateOptionData } from '../store/slices/optionChainSlice';\n\nexport const useMarketData = (symbol: string, selectedExpiry?: string) => {\n    const dispatch = useDispatch();\n    const optionChainData = useSelector((state: RootState) => state.optionChain.data);\n\n    const handleMarketData = useCallback((message: WSMessage) => {\n        if (message.type === 'MARKET_DATA' && message.data) {\n            const marketData = message.data as MarketData;\n            // Update the specific option's data in the chain\n            if (optionChainData) {\n                const updatedStrikes = optionChainData.strikes.map(strike => {\n                    if (strike.call.instrument_token === marketData.instrument_token) {\n                        return {\n                            ...strike,\n                            call: {\n                                ...strike.call,\n                                ltp: marketData.last_price,\n                                oi: marketData.oi,\n                                change: marketData.change,\n                            },\n                        };\n                    }\n                    if (strike.put.instrument_token === marketData.instrument_token) {\n                        return {\n                            ...strike,\n                            put: {\n                                ...strike.put,\n                                ltp: marketData.last_price,\n                                oi: marketData.oi,\n                                change: marketData.change,\n                            },\n                        };\n                    }\n                    return strike;\n                });\n\n                dispatch(updateOptionData({ strikes: updatedStrikes }));\n            }\n        }\n    }, [optionChainData, dispatch]);\n\n    // Fetch initial option chain data\n    useEffect(() => {\n        const fetchOptionChain = async () => {\n            if (!symbol || !selectedExpiry) return;\n\n            try {\n                dispatch(setLoading(true));\n                const response = await optionsApi.getOptionChain(symbol, selectedExpiry);\n                dispatch(setOptionChainData(response.data));\n            } catch (error) {\n                dispatch(setError(error instanceof Error ? error.message : 'Failed to fetch option chain'));\n            } finally {\n                dispatch(setLoading(false));\n            }\n        };\n\n        fetchOptionChain();\n    }, [symbol, selectedExpiry, dispatch]);\n\n    // Subscribe to market data updates\n    useEffect(() => {\n        if (optionChainData?.strikes) {\n            // Extract instrument tokens from both calls and puts\n            const instrumentTokens = optionChainData.strikes.flatMap(strike => [\n                strike.call.instrument_token,\n                strike.put.instrument_token\n            ]);\n            \n            webSocketService.subscribe(instrumentTokens);\n            webSocketService.addMessageHandler(handleMarketData);\n\n            return () => {\n                webSocketService.unsubscribe(instrumentTokens);\n                webSocketService.removeMessageHandler(handleMarketData);\n            };\n        }\n    }, [optionChainData, handleMarketData]);\n\n    return {\n        optionChainData,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}