{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  connected: false,\n  subscriptions: [],\n  clientId: null\n};\nclass WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.baseUrl = void 0;\n    this.messageHandlers = new Set();\n    this.subscriptions = new Set();\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = 3000;\n    this.clientId = null;\n    this.baseUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/api/v1/kite/ws';\n  }\n  connect(clientId, initialSubscriptions = []) {\n    this.clientId = clientId;\n    const url = `${this.baseUrl}/${clientId}`;\n    try {\n      this.ws = new WebSocket(url);\n      this.ws.onopen = () => {\n        console.log('WebSocket connected');\n        this.reconnectAttempts = 0;\n\n        // Resubscribe to previous subscriptions\n        if (initialSubscriptions.length > 0) {\n          this.subscribe(initialSubscriptions);\n        }\n      };\n      this.ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this.messageHandlers.forEach(handler => handler(data));\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n      this.ws.onclose = () => {\n        console.log('WebSocket disconnected');\n        this.handleDisconnect();\n      };\n      this.ws.onerror = error => {\n        console.error('WebSocket error:', error);\n      };\n    } catch (error) {\n      console.error('Error connecting to WebSocket:', error);\n      this.handleDisconnect();\n    }\n  }\n  handleDisconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`WebSocket disconnected. Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      setTimeout(() => {\n        if (this.clientId) {\n          this.connect(this.clientId, Array.from(this.subscriptions));\n        }\n      }, this.reconnectTimeout);\n    } else {\n      console.error('Max reconnection attempts reached');\n    }\n  }\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.messageHandlers.clear();\n    this.subscriptions.clear();\n    this.clientId = null;\n  }\n  subscribe(instrumentTokens) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      return;\n    }\n    instrumentTokens.forEach(token => this.subscriptions.add(token));\n    this.ws.send(JSON.stringify({\n      type: 'subscribe',\n      tokens: instrumentTokens\n    }));\n  }\n  unsubscribe(instrumentTokens) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      return;\n    }\n    instrumentTokens.forEach(token => this.subscriptions.delete(token));\n    this.ws.send(JSON.stringify({\n      type: 'unsubscribe',\n      tokens: instrumentTokens\n    }));\n  }\n  addMessageHandler(handler) {\n    this.messageHandlers.add(handler);\n  }\n  removeMessageHandler(handler) {\n    this.messageHandlers.delete(handler);\n  }\n}\nexport const websocketService = new WebSocketService();\nexport const websocketSlice = createSlice({\n  name: 'websocket',\n  initialState,\n  reducers: {\n    setConnected: (state, action) => {\n      state.connected = action.payload;\n    },\n    setClientId: (state, action) => {\n      state.clientId = action.payload;\n    },\n    addSubscription: (state, action) => {\n      if (!state.subscriptions.includes(action.payload)) {\n        state.subscriptions.push(action.payload);\n      }\n    },\n    removeSubscription: (state, action) => {\n      state.subscriptions = state.subscriptions.filter(id => id !== action.payload);\n    }\n  }\n});\nexport const {\n  setConnected,\n  setClientId,\n  addSubscription,\n  removeSubscription\n} = websocketSlice.actions;\nexport const websocketReducer = websocketSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","connected","subscriptions","clientId","WebSocketService","constructor","ws","baseUrl","messageHandlers","Set","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","process","env","REACT_APP_WS_URL","connect","initialSubscriptions","url","WebSocket","onopen","console","log","length","subscribe","onmessage","event","data","JSON","parse","forEach","handler","error","onclose","handleDisconnect","onerror","setTimeout","Array","from","disconnect","close","clear","instrumentTokens","readyState","OPEN","token","add","send","stringify","type","tokens","unsubscribe","delete","addMessageHandler","removeMessageHandler","websocketService","websocketSlice","name","reducers","setConnected","state","action","payload","setClientId","addSubscription","includes","push","removeSubscription","filter","id","actions","websocketReducer","reducer"],"sources":["C:/Users/inder/CascadeProjects/KavasCAPITALFASTAPI-new/frontend/src/services/websocket.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { MarketData } from '../types/market';\n\ninterface WebSocketState {\n  connected: boolean;\n  subscriptions: number[];\n  clientId: string | null;\n}\n\nconst initialState: WebSocketState = {\n  connected: false,\n  subscriptions: [],\n  clientId: null,\n};\n\ntype MessageHandler = (data: MarketData) => void;\n\nclass WebSocketService {\n  private ws: WebSocket | null = null;\n  private readonly baseUrl: string;\n  private messageHandlers: Set<MessageHandler> = new Set();\n  private subscriptions: Set<number> = new Set();\n  private reconnectAttempts: number = 0;\n  private readonly maxReconnectAttempts: number = 5;\n  private readonly reconnectTimeout: number = 3000;\n  private clientId: string | null = null;\n\n  constructor() {\n    this.baseUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/api/v1/kite/ws';\n  }\n\n  connect(clientId: string, initialSubscriptions: number[] = []) {\n    this.clientId = clientId;\n    const url = `${this.baseUrl}/${clientId}`;\n    \n    try {\n      this.ws = new WebSocket(url);\n      \n      this.ws.onopen = () => {\n        console.log('WebSocket connected');\n        this.reconnectAttempts = 0;\n        \n        // Resubscribe to previous subscriptions\n        if (initialSubscriptions.length > 0) {\n          this.subscribe(initialSubscriptions);\n        }\n      };\n\n      this.ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          this.messageHandlers.forEach(handler => handler(data));\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n\n      this.ws.onclose = () => {\n        console.log('WebSocket disconnected');\n        this.handleDisconnect();\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n      };\n    } catch (error) {\n      console.error('Error connecting to WebSocket:', error);\n      this.handleDisconnect();\n    }\n  }\n\n  private handleDisconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`WebSocket disconnected. Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      \n      setTimeout(() => {\n        if (this.clientId) {\n          this.connect(this.clientId, Array.from(this.subscriptions));\n        }\n      }, this.reconnectTimeout);\n    } else {\n      console.error('Max reconnection attempts reached');\n    }\n  }\n\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.messageHandlers.clear();\n    this.subscriptions.clear();\n    this.clientId = null;\n  }\n\n  subscribe(instrumentTokens: number[]) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      return;\n    }\n\n    instrumentTokens.forEach(token => this.subscriptions.add(token));\n    \n    this.ws.send(JSON.stringify({\n      type: 'subscribe',\n      tokens: instrumentTokens,\n    }));\n  }\n\n  unsubscribe(instrumentTokens: number[]) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket is not connected');\n      return;\n    }\n\n    instrumentTokens.forEach(token => this.subscriptions.delete(token));\n    \n    this.ws.send(JSON.stringify({\n      type: 'unsubscribe',\n      tokens: instrumentTokens,\n    }));\n  }\n\n  addMessageHandler(handler: MessageHandler) {\n    this.messageHandlers.add(handler);\n  }\n\n  removeMessageHandler(handler: MessageHandler) {\n    this.messageHandlers.delete(handler);\n  }\n}\n\nexport const websocketService = new WebSocketService();\n\nexport const websocketSlice = createSlice({\n  name: 'websocket',\n  initialState,\n  reducers: {\n    setConnected: (state, action: PayloadAction<boolean>) => {\n      state.connected = action.payload;\n    },\n    setClientId: (state, action: PayloadAction<string>) => {\n      state.clientId = action.payload;\n    },\n    addSubscription: (state, action: PayloadAction<number>) => {\n      if (!state.subscriptions.includes(action.payload)) {\n        state.subscriptions.push(action.payload);\n      }\n    },\n    removeSubscription: (state, action: PayloadAction<number>) => {\n      state.subscriptions = state.subscriptions.filter(id => id !== action.payload);\n    },\n  },\n});\n\nexport const {\n  setConnected,\n  setClientId,\n  addSubscription,\n  removeSubscription,\n} = websocketSlice.actions;\n\nexport const websocketReducer = websocketSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}