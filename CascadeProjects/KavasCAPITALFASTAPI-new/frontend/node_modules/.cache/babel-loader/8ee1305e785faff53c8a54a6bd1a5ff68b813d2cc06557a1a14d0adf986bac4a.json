{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { setOptionChainData, setError } from '../store/slices/optionChainSlice';\n// Constants\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 3000;\nconst HEARTBEAT_INTERVAL = 30000;\nconst RECONNECT_INTERVAL = 5000;\nexport const useMarketData = (symbol, expiry) => {\n  _s();\n  const dispatch = useDispatch();\n  const wsRef = useRef(null);\n  const reconnectAttempts = useRef(0);\n  const heartbeatInterval = useRef();\n  const {\n    optionChainData,\n    error,\n    isLoading\n  } = useSelector(state => state.optionChain);\n\n  // Handle market data updates\n  const handleMarketData = useCallback(marketData => {\n    if (!optionChainData) return;\n    const updatedStrikes = optionChainData.strikes.map(strike => {\n      var _strike$call, _strike$put;\n      if (((_strike$call = strike.call) === null || _strike$call === void 0 ? void 0 : _strike$call.instrument_token) === marketData.instrument_token) {\n        return {\n          ...strike,\n          call: {\n            ...strike.call,\n            ltp: marketData.last_price,\n            change: marketData.change,\n            volume: marketData.volume,\n            oi: marketData.oi\n          }\n        };\n      }\n      if (((_strike$put = strike.put) === null || _strike$put === void 0 ? void 0 : _strike$put.instrument_token) === marketData.instrument_token) {\n        return {\n          ...strike,\n          put: {\n            ...strike.put,\n            ltp: marketData.last_price,\n            change: marketData.change,\n            volume: marketData.volume,\n            oi: marketData.oi\n          }\n        };\n      }\n      return strike;\n    });\n    dispatch(setOptionChainData({\n      ...optionChainData,\n      strikes: updatedStrikes\n    }));\n  }, [optionChainData, dispatch]);\n\n  // Subscribe to instruments\n  const subscribeToInstruments = useCallback(() => {\n    if (!wsRef.current || !optionChainData || wsRef.current.readyState !== WebSocket.OPEN) return;\n    const instruments = optionChainData.strikes.flatMap(strike => {\n      var _strike$call2, _strike$put2;\n      const tokens = [];\n      if ((_strike$call2 = strike.call) !== null && _strike$call2 !== void 0 && _strike$call2.instrument_token) tokens.push(strike.call.instrument_token);\n      if ((_strike$put2 = strike.put) !== null && _strike$put2 !== void 0 && _strike$put2.instrument_token) tokens.push(strike.put.instrument_token);\n      return tokens;\n    });\n    if (instruments.length > 0) {\n      wsRef.current.send(JSON.stringify({\n        type: 'subscribe',\n        instruments\n      }));\n    }\n  }, [optionChainData]);\n\n  // Setup WebSocket connection\n  const setupWebSocket = useCallback(() => {\n    const token = localStorage.getItem('access_token');\n    if (!token || !symbol || !expiry) return;\n\n    // Close existing connection if any\n    if (wsRef.current) {\n      wsRef.current.close();\n      clearInterval(heartbeatInterval.current);\n    }\n    const ws = new WebSocket(`ws://localhost:8000/options/${symbol}/${expiry}?token=${token}`);\n    wsRef.current = ws;\n    ws.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        switch (message.type) {\n          case 'MARKET_DATA':\n            if (message.data) handleMarketData(message.data);\n            break;\n          case 'OPTION_CHAIN':\n            if (message.data) {\n              dispatch(setOptionChainData(message.data));\n              subscribeToInstruments();\n            }\n            break;\n          case 'ERROR':\n            dispatch(setError(message.error || 'Unknown error occurred'));\n            break;\n          case 'pong':\n            // Heartbeat response received\n            break;\n          default:\n            console.warn('Unknown message type:', message.type);\n        }\n      } catch (err) {\n        console.error('Error processing WebSocket message:', err);\n        dispatch(setError('Error processing market data'));\n      }\n    };\n    ws.onerror = error => {\n      console.error('WebSocket error:', error);\n      dispatch(setError('Connection error occurred'));\n    };\n    ws.onclose = () => {\n      console.log('WebSocket connection closed');\n      clearInterval(heartbeatInterval.current);\n\n      // Attempt reconnection if not at max retries\n      if (reconnectAttempts.current < MAX_RETRIES) {\n        setTimeout(() => {\n          reconnectAttempts.current += 1;\n          setupWebSocket();\n        }, RECONNECT_INTERVAL);\n      } else {\n        dispatch(setError('Maximum reconnection attempts reached'));\n      }\n    };\n    ws.onopen = () => {\n      console.log('WebSocket connection established');\n      reconnectAttempts.current = 0;\n      subscribeToInstruments();\n\n      // Setup heartbeat\n      heartbeatInterval.current = setInterval(() => {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(JSON.stringify({\n            type: 'ping'\n          }));\n        }\n      }, HEARTBEAT_INTERVAL);\n    };\n  }, [symbol, expiry, dispatch, handleMarketData, subscribeToInstruments]);\n  useEffect(() => {\n    setupWebSocket();\n    return () => {\n      if (wsRef.current) {\n        wsRef.current.close();\n        clearInterval(heartbeatInterval.current);\n      }\n    };\n  }, [setupWebSocket]);\n  return {\n    optionChainData,\n    error,\n    isLoading\n  };\n};\n_s(useMarketData, \"46RULdM/gYQwljG9u1u9JHZSEaM=\", false, function () {\n  return [useDispatch, useSelector];\n});","map":{"version":3,"names":["useEffect","useRef","useCallback","useDispatch","useSelector","setOptionChainData","setError","MAX_RETRIES","RETRY_DELAY","HEARTBEAT_INTERVAL","RECONNECT_INTERVAL","useMarketData","symbol","expiry","_s","dispatch","wsRef","reconnectAttempts","heartbeatInterval","optionChainData","error","isLoading","state","optionChain","handleMarketData","marketData","updatedStrikes","strikes","map","strike","_strike$call","_strike$put","call","instrument_token","ltp","last_price","change","volume","oi","put","subscribeToInstruments","current","readyState","WebSocket","OPEN","instruments","flatMap","_strike$call2","_strike$put2","tokens","push","length","send","JSON","stringify","type","setupWebSocket","token","localStorage","getItem","close","clearInterval","ws","onmessage","event","message","parse","data","console","warn","err","onerror","onclose","log","setTimeout","onopen","setInterval"],"sources":["C:/Users/inder/CascadeProjects/KavasCAPITALFASTAPI-new/frontend/src/hooks/useMarketData.ts"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { setOptionChainData, setError } from '../store/slices/optionChainSlice';\nimport { MarketData, OptionChainData, WSMessage, StrikeData } from '../types/options';\nimport { RootState } from '../store/store';\n\n// Constants\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 3000;\nconst HEARTBEAT_INTERVAL = 30000;\nconst RECONNECT_INTERVAL = 5000;\n\nexport const useMarketData = (symbol: string, expiry: string) => {\n    const dispatch = useDispatch();\n    const wsRef = useRef<WebSocket | null>(null);\n    const reconnectAttempts = useRef(0);\n    const heartbeatInterval = useRef<NodeJS.Timeout>();\n    const { optionChainData, error, isLoading } = useSelector((state: RootState) => state.optionChain);\n\n    // Handle market data updates\n    const handleMarketData = useCallback((marketData: MarketData) => {\n        if (!optionChainData) return;\n\n        const updatedStrikes = optionChainData.strikes.map((strike: StrikeData) => {\n            if (strike.call?.instrument_token === marketData.instrument_token) {\n                return {\n                    ...strike,\n                    call: {\n                        ...strike.call,\n                        ltp: marketData.last_price,\n                        change: marketData.change,\n                        volume: marketData.volume,\n                        oi: marketData.oi\n                    }\n                };\n            }\n            if (strike.put?.instrument_token === marketData.instrument_token) {\n                return {\n                    ...strike,\n                    put: {\n                        ...strike.put,\n                        ltp: marketData.last_price,\n                        change: marketData.change,\n                        volume: marketData.volume,\n                        oi: marketData.oi\n                    }\n                };\n            }\n            return strike;\n        });\n\n        dispatch(setOptionChainData({\n            ...optionChainData,\n            strikes: updatedStrikes\n        }));\n    }, [optionChainData, dispatch]);\n\n    // Subscribe to instruments\n    const subscribeToInstruments = useCallback(() => {\n        if (!wsRef.current || !optionChainData || wsRef.current.readyState !== WebSocket.OPEN) return;\n\n        const instruments = optionChainData.strikes.flatMap((strike: StrikeData) => {\n            const tokens: number[] = [];\n            if (strike.call?.instrument_token) tokens.push(strike.call.instrument_token);\n            if (strike.put?.instrument_token) tokens.push(strike.put.instrument_token);\n            return tokens;\n        });\n\n        if (instruments.length > 0) {\n            wsRef.current.send(JSON.stringify({\n                type: 'subscribe',\n                instruments\n            }));\n        }\n    }, [optionChainData]);\n\n    // Setup WebSocket connection\n    const setupWebSocket = useCallback(() => {\n        const token = localStorage.getItem('access_token');\n        if (!token || !symbol || !expiry) return;\n\n        // Close existing connection if any\n        if (wsRef.current) {\n            wsRef.current.close();\n            clearInterval(heartbeatInterval.current);\n        }\n\n        const ws = new WebSocket(`ws://localhost:8000/options/${symbol}/${expiry}?token=${token}`);\n        wsRef.current = ws;\n\n        ws.onmessage = (event) => {\n            try {\n                const message = JSON.parse(event.data) as WSMessage;\n                \n                switch (message.type) {\n                    case 'MARKET_DATA':\n                        if (message.data) handleMarketData(message.data as MarketData);\n                        break;\n                    case 'OPTION_CHAIN':\n                        if (message.data) {\n                            dispatch(setOptionChainData(message.data as OptionChainData));\n                            subscribeToInstruments();\n                        }\n                        break;\n                    case 'ERROR':\n                        dispatch(setError(message.error || 'Unknown error occurred'));\n                        break;\n                    case 'pong':\n                        // Heartbeat response received\n                        break;\n                    default:\n                        console.warn('Unknown message type:', message.type);\n                }\n            } catch (err) {\n                console.error('Error processing WebSocket message:', err);\n                dispatch(setError('Error processing market data'));\n            }\n        };\n\n        ws.onerror = (error) => {\n            console.error('WebSocket error:', error);\n            dispatch(setError('Connection error occurred'));\n        };\n\n        ws.onclose = () => {\n            console.log('WebSocket connection closed');\n            clearInterval(heartbeatInterval.current);\n\n            // Attempt reconnection if not at max retries\n            if (reconnectAttempts.current < MAX_RETRIES) {\n                setTimeout(() => {\n                    reconnectAttempts.current += 1;\n                    setupWebSocket();\n                }, RECONNECT_INTERVAL);\n            } else {\n                dispatch(setError('Maximum reconnection attempts reached'));\n            }\n        };\n\n        ws.onopen = () => {\n            console.log('WebSocket connection established');\n            reconnectAttempts.current = 0;\n            subscribeToInstruments();\n\n            // Setup heartbeat\n            heartbeatInterval.current = setInterval(() => {\n                if (ws.readyState === WebSocket.OPEN) {\n                    ws.send(JSON.stringify({ type: 'ping' }));\n                }\n            }, HEARTBEAT_INTERVAL);\n        };\n    }, [symbol, expiry, dispatch, handleMarketData, subscribeToInstruments]);\n\n    useEffect(() => {\n        setupWebSocket();\n\n        return () => {\n            if (wsRef.current) {\n                wsRef.current.close();\n                clearInterval(heartbeatInterval.current);\n            }\n        };\n    }, [setupWebSocket]);\n\n    return { optionChainData, error, isLoading };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}