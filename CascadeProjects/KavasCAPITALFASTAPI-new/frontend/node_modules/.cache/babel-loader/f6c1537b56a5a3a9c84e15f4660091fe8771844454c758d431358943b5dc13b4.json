{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { optionsApi } from '../services/api';\nimport { webSocketService } from '../services/websocket';\nimport { setLoading, setOptionChainData, updateOptionData } from '../store/slices/optionChainSlice';\nexport const useMarketData = (symbol, selectedExpiry) => {\n  _s();\n  const dispatch = useDispatch();\n  const optionChainData = useSelector(state => state.optionChain.data);\n  const [instrumentTokens, setInstrumentTokens] = useState([]);\n  const [error, setError] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const handleMarketData = useCallback(message => {\n    try {\n      if (message.type === 'MARKET_DATA' && message.data) {\n        const marketData = message.data;\n        // Update the specific option's data in the chain\n        if (optionChainData) {\n          const updatedStrikes = optionChainData.strikes.map(strike => {\n            var _strike$call, _strike$put;\n            if (((_strike$call = strike.call) === null || _strike$call === void 0 ? void 0 : _strike$call.instrument_token) === marketData.instrument_token) {\n              return {\n                ...strike,\n                call: {\n                  ...strike.call,\n                  ltp: marketData.last_price,\n                  oi: marketData.oi,\n                  change: marketData.change\n                }\n              };\n            }\n            if (((_strike$put = strike.put) === null || _strike$put === void 0 ? void 0 : _strike$put.instrument_token) === marketData.instrument_token) {\n              return {\n                ...strike,\n                put: {\n                  ...strike.put,\n                  ltp: marketData.last_price,\n                  oi: marketData.oi,\n                  change: marketData.change\n                }\n              };\n            }\n            return strike;\n          });\n          dispatch(updateOptionData({\n            strikes: updatedStrikes\n          }));\n        }\n      } else if (message.type === 'option_chain') {\n        setOptionChainData(message.data);\n        setError(null);\n        setIsLoading(false);\n\n        // Extract instrument tokens from option chain\n        const tokens = [];\n        if (message.data) {\n          if (message.data.calls) {\n            message.data.calls.forEach(option => {\n              if (option.instrument_token) {\n                tokens.push(option.instrument_token);\n              }\n            });\n          }\n          if (message.data.puts) {\n            message.data.puts.forEach(option => {\n              if (option.instrument_token) {\n                tokens.push(option.instrument_token);\n              }\n            });\n          }\n        }\n        setInstrumentTokens(tokens);\n      } else if (message.type === 'error') {\n        setError(message.message || 'Unknown error occurred');\n        setIsLoading(false);\n      }\n    } catch (err) {\n      console.error('Error handling market data:', err);\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n      setIsLoading(false);\n    }\n  }, [optionChainData, dispatch]);\n\n  // Connect to WebSocket when symbol and expiry change\n  useEffect(() => {\n    setIsLoading(true);\n    setError(null);\n    if (symbol && selectedExpiry) {\n      webSocketService.connect(symbol, selectedExpiry);\n      webSocketService.addMessageHandler(handleMarketData);\n      return () => {\n        webSocketService.removeMessageHandler(handleMarketData);\n        webSocketService.disconnect();\n      };\n    }\n  }, [symbol, selectedExpiry, handleMarketData]);\n\n  // Fetch initial option chain data\n  useEffect(() => {\n    const fetchOptionChain = async () => {\n      if (!symbol || !selectedExpiry) return;\n      try {\n        dispatch(setLoading(true));\n        const response = await optionsApi.getOptionChain(symbol, selectedExpiry);\n        dispatch(setOptionChainData(response.data));\n      } catch (error) {\n        dispatch(setError(error instanceof Error ? error.message : 'Failed to fetch option chain'));\n      } finally {\n        dispatch(setLoading(false));\n      }\n    };\n    fetchOptionChain();\n  }, [symbol, selectedExpiry, dispatch]);\n\n  // Subscribe to market data updates\n  useEffect(() => {\n    if (optionChainData !== null && optionChainData !== void 0 && optionChainData.strikes) {\n      // Extract instrument tokens from both calls and puts, filtering out undefined values\n      const tokens = [];\n      optionChainData.strikes.flatMap(strike => {\n        var _strike$call2, _strike$put2;\n        return [(_strike$call2 = strike.call) === null || _strike$call2 === void 0 ? void 0 : _strike$call2.instrument_token, (_strike$put2 = strike.put) === null || _strike$put2 === void 0 ? void 0 : _strike$put2.instrument_token];\n      }).filter(token => token !== undefined).forEach(token => tokens.push(token));\n      if (tokens.length > 0) {\n        console.log('Subscribing to instruments:', tokens);\n        webSocketService.subscribe(tokens);\n      }\n      setInstrumentTokens(tokens);\n    }\n  }, [optionChainData]);\n  useEffect(() => {\n    if (instrumentTokens.length > 0) {\n      console.log('Subscribing to instruments:', instrumentTokens);\n      webSocketService.subscribe(instrumentTokens);\n    }\n    return () => {\n      if (instrumentTokens.length > 0) {\n        console.log('Unsubscribing from instruments:', instrumentTokens);\n        webSocketService.unsubscribe(instrumentTokens);\n      }\n    };\n  }, [instrumentTokens]);\n  return {\n    optionChainData,\n    error,\n    isLoading\n  };\n};\n_s(useMarketData, \"KO61cfO04p2evqgbTF0GPetxf1s=\", false, function () {\n  return [useDispatch, useSelector];\n});","map":{"version":3,"names":["useCallback","useEffect","useState","useDispatch","useSelector","optionsApi","webSocketService","setLoading","setOptionChainData","updateOptionData","useMarketData","symbol","selectedExpiry","_s","dispatch","optionChainData","state","optionChain","data","instrumentTokens","setInstrumentTokens","error","setError","isLoading","setIsLoading","handleMarketData","message","type","marketData","updatedStrikes","strikes","map","strike","_strike$call","_strike$put","call","instrument_token","ltp","last_price","oi","change","put","tokens","calls","forEach","option","push","puts","err","console","Error","connect","addMessageHandler","removeMessageHandler","disconnect","fetchOptionChain","response","getOptionChain","flatMap","_strike$call2","_strike$put2","filter","token","undefined","length","log","subscribe","unsubscribe"],"sources":["C:/Users/inder/CascadeProjects/KavasCAPITALFASTAPI-new/frontend/src/hooks/useMarketData.ts"],"sourcesContent":["import { useCallback, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { optionsApi } from '../services/api';\nimport { webSocketService } from '../services/websocket';\nimport type { MarketData, WSMessage, OptionChainData } from '../types/options';\nimport { RootState } from '../store';\nimport { setError, setLoading, setOptionChainData, updateOptionData } from '../store/slices/optionChainSlice';\n\nexport const useMarketData = (symbol: string, selectedExpiry?: string) => {\n    const dispatch = useDispatch();\n    const optionChainData = useSelector((state: RootState) => state.optionChain.data);\n    const [instrumentTokens, setInstrumentTokens] = useState<number[]>([]);\n    const [error, setError] = useState<string | null>(null);\n    const [isLoading, setIsLoading] = useState<boolean>(true);\n\n    const handleMarketData = useCallback((message: WSMessage) => {\n        try {\n            if (message.type === 'MARKET_DATA' && message.data) {\n                const marketData = message.data as MarketData;\n                // Update the specific option's data in the chain\n                if (optionChainData) {\n                    const updatedStrikes = optionChainData.strikes.map(strike => {\n                        if (strike.call?.instrument_token === marketData.instrument_token) {\n                            return {\n                                ...strike,\n                                call: {\n                                    ...strike.call,\n                                    ltp: marketData.last_price,\n                                    oi: marketData.oi,\n                                    change: marketData.change,\n                                },\n                            };\n                        }\n                        if (strike.put?.instrument_token === marketData.instrument_token) {\n                            return {\n                                ...strike,\n                                put: {\n                                    ...strike.put,\n                                    ltp: marketData.last_price,\n                                    oi: marketData.oi,\n                                    change: marketData.change,\n                                },\n                            };\n                        }\n                        return strike;\n                    });\n\n                    dispatch(updateOptionData({ strikes: updatedStrikes }));\n                }\n            } else if (message.type === 'option_chain') {\n                setOptionChainData(message.data);\n                setError(null);\n                setIsLoading(false);\n\n                // Extract instrument tokens from option chain\n                const tokens: number[] = [];\n                if (message.data) {\n                    if (message.data.calls) {\n                        message.data.calls.forEach(option => {\n                            if (option.instrument_token) {\n                                tokens.push(option.instrument_token);\n                            }\n                        });\n                    }\n                    if (message.data.puts) {\n                        message.data.puts.forEach(option => {\n                            if (option.instrument_token) {\n                                tokens.push(option.instrument_token);\n                            }\n                        });\n                    }\n                }\n                setInstrumentTokens(tokens);\n            } else if (message.type === 'error') {\n                setError(message.message || 'Unknown error occurred');\n                setIsLoading(false);\n            }\n        } catch (err) {\n            console.error('Error handling market data:', err);\n            setError(err instanceof Error ? err.message : 'Unknown error occurred');\n            setIsLoading(false);\n        }\n    }, [optionChainData, dispatch]);\n\n    // Connect to WebSocket when symbol and expiry change\n    useEffect(() => {\n        setIsLoading(true);\n        setError(null);\n\n        if (symbol && selectedExpiry) {\n            webSocketService.connect(symbol, selectedExpiry);\n            webSocketService.addMessageHandler(handleMarketData);\n\n            return () => {\n                webSocketService.removeMessageHandler(handleMarketData);\n                webSocketService.disconnect();\n            };\n        }\n    }, [symbol, selectedExpiry, handleMarketData]);\n\n    // Fetch initial option chain data\n    useEffect(() => {\n        const fetchOptionChain = async () => {\n            if (!symbol || !selectedExpiry) return;\n\n            try {\n                dispatch(setLoading(true));\n                const response = await optionsApi.getOptionChain(symbol, selectedExpiry);\n                dispatch(setOptionChainData(response.data));\n            } catch (error) {\n                dispatch(setError(error instanceof Error ? error.message : 'Failed to fetch option chain'));\n            } finally {\n                dispatch(setLoading(false));\n            }\n        };\n\n        fetchOptionChain();\n    }, [symbol, selectedExpiry, dispatch]);\n\n    // Subscribe to market data updates\n    useEffect(() => {\n        if (optionChainData?.strikes) {\n            // Extract instrument tokens from both calls and puts, filtering out undefined values\n            const tokens: number[] = [];\n            optionChainData.strikes\n                .flatMap(strike => [\n                    strike.call?.instrument_token,\n                    strike.put?.instrument_token\n                ])\n                .filter((token): token is number => token !== undefined)\n                .forEach(token => tokens.push(token));\n\n            if (tokens.length > 0) {\n                console.log('Subscribing to instruments:', tokens);\n                webSocketService.subscribe(tokens);\n            }\n\n            setInstrumentTokens(tokens);\n        }\n    }, [optionChainData]);\n\n    useEffect(() => {\n        if (instrumentTokens.length > 0) {\n            console.log('Subscribing to instruments:', instrumentTokens);\n            webSocketService.subscribe(instrumentTokens);\n        }\n\n        return () => {\n            if (instrumentTokens.length > 0) {\n                console.log('Unsubscribing from instruments:', instrumentTokens);\n                webSocketService.unsubscribe(instrumentTokens);\n            }\n        };\n    }, [instrumentTokens]);\n\n    return {\n        optionChainData,\n        error,\n        isLoading\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}